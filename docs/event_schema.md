# Telemetry event schema and data policy

## Purpose
This document is the **telemetry contract** for the game.

We intentionally **maximize useful telemetry** to support internal operations:
- Product analytics & iteration (funnels, difficulty, time-to-first-win, retention when available)
- QA/debugging (repro traces, state + outcome visibility)
- Reliability (crashes, errors, performance)
- Security/integrity (abuse prevention, rate limiting, anomaly detection)

Non-goals:
- Advertising, cross-product tracking, or selling/sharing telemetry data.

This schema is designed so we can expand telemetry safely without re-litigating the rules every sprint.

---

## Data collection principles (telemetry-first, still safe)
1) **Maximize usefulness**
   - If an event helps us improve onboarding, balancing, UX clarity, debugging, or stability: **instrument it**.
   - Prefer structured data that enables both analytics *and* reproducible debugging.

2) **No direct PII, no free-form user text**
   - Do not collect names, emails, phone numbers, addresses, photos, voice, or any free-form user text fields.
   - Do not log raw user-agent strings or other “fingerprint-style” payloads unless explicitly approved.

3) **Pseudonymous identifiers are allowed and expected**
   - We use stable random identifiers to link sessions and enable longitudinal analysis.
   - Identifiers must be **randomly generated by us**, not derived from hardware, OS unique IDs, or fingerprinting.

4) **Consent-aware by design**
   - Telemetry should be implementable in a way that can honor “telemetry enabled/disabled” and “consent version” without breaking the schema.
   - The schema supports tracking consent state without requiring PII.

5) **Determinism-safe**
   - Telemetry must never change gameplay outcomes.
   - Event payloads should be derived from the **authoritative deterministic simulation state** + explicit inputs/results.

6) **Never block gameplay**
   - Telemetry is best-effort. Queue/batch if needed. Dropping telemetry must not break gameplay.

---

## Identifier model (standardized)
All identifiers are **generated client-side** (uuidv4 recommended).

| Field | Scope | Persistence | Meaning |
|---|---|---|---|
| `player_id` | player/install | stable | Stable pseudonymous ID stored locally. Regenerated only by “Reset all data” (or equivalent). Not based on device fingerprinting. |
| `session_id` | session | per launch | New ID per app launch (or “new session” definition). Used to group events within a play session. |
| `attempt_id` | level attempt | per attempt | New ID per level start/restart. |
| `event_id` | event | unique | Unique per emitted event for dedupe/debug. |

Notes:
- If you later add profiles, keep `player_id` as “active profile id” and introduce `install_id` separately. For now, `player_id` is enough.

---

## Standard event envelope (included on every event)
Every event must include these fields (even if “not used yet”):

| Field | Type | Required | Notes |
|---|---:|---:|---|
| `event_name` | string | ✅ | e.g., `manual_move` |
| `event_id` | uuid | ✅ | uuidv4 |
| `schema_version` | int | ✅ | Start at `1`. Bump only for breaking changes. |
| `t_ms` | int | ✅ | Monotonic ms since `session_start` (NOT wall-clock time). |
| `player_id` | uuid | ✅ | Stable pseudonymous identifier |
| `session_id` | uuid | ✅ | Per-session identifier |
| `app_version` | string | ✅ | SemVer, injected by release process |
| `platform` | string | ✅ | e.g., `web`, `desktop` |
| `telemetry_enabled` | bool | ✅ | Allows opt-out/disable without schema changes |
| `consent_version` | string | ⛔️* | Include when consent UX exists (e.g., `v1`) |

\* `consent_version` can be empty until consent UX exists; keep the field reserved.

Optional but recommended for debugging:
- `build_sha` (short git SHA)
- `content_version` (levels/content pack version)
- `locale` (coarse locale code)

---

## Event catalog (Sprint 1 + forward-compatible)
### Session lifecycle
| Event | When | Properties (in addition to envelope) |
|---|---|---|
| `session_start` | On app start / fresh boot | `cold_start` (bool) |
| `session_end` | On quit/close/background (best effort) | `reason` (`quit`\|`crash`\|`background`\|`unknown`) |

### Level / attempt lifecycle
| Event | When | Properties |
|---|---|---|
| `level_start` | Level becomes active (new or restart) | `level_id` (string), `attempt_id` (uuid), `entry` (`select`\|`restart`\|`next`) |
| `level_win` | Goal reached | `level_id`, `attempt_id`, `steps_taken` (int), `attempt_elapsed_ms` (int) |
| `level_fail` | Attempt ends without win | `level_id`, `attempt_id`, `attempt_elapsed_ms` (int), `reason` (`restart`\|`quit`\|`blocked_cap`\|`other`) |

### Movement / input (high volume)
| Event | When | Properties |
|---|---|---|
| `manual_move` | Each manual movement attempt | `level_id`, `attempt_id`, `sequence_index` (int), `direction` (`up`\|`down`\|`left`\|`right`), `outcome` (`moved`\|`blocked`), `position_before` (`{x:int,y:int}`), `position_after` (`{x:int,y:int}`), `blocked_reason` (`wall`\|`bounds`\|`rule`\|`unknown`, optional) |

Why include both positions?
- It makes telemetry resilient to missing events and makes debugging far easier.

### Reliability / errors (strict allowlist only)
| Event | When | Properties |
|---|---|---|
| `error` | On handled error (non-fatal) | `code` (string enum), `context` (string enum), `details` (object allowlist only) |
| `crash` | On crash reporting integration (future) | (depends on crash system; must avoid PII/free text) |

---

## Derived metrics (examples)
- **Time-to-first-win (real time):**
  - `first(level_win.t_ms) - first(level_start.t_ms)` for a given `level_id` (or from `session_start.t_ms` if you mean “time from boot”).
- **Level completion rate:**
  - `count(level_win) / count(level_start)` grouped by `level_id`.
- **Blocked move frequency:**
  - `count(manual_move where outcome=blocked) / count(manual_move)` grouped by `level_id` or `attempt_id`.

---

## Schema evolution rules (to keep analytics stable)
- Additive changes are preferred (new optional fields).
- Do not rename event names. If semantics change, introduce a new event name.
- Never reuse an enum value with different meaning.
- If a breaking change is unavoidable, bump `schema_version` and support both versions during migration.

---

## Implementation guardrails (for later code work)
- Centralize emission in a telemetry service that enforces:
  - field allowlists
  - enum allowlists
  - payload size limits
- Telemetry must be best-effort and must not block gameplay.
- Keep timing monotonic (`t_ms`) and avoid wall-clock timestamps by default.
- Store `player_id` locally; do not derive IDs from OS/device fingerprints.
